-- Update handle_swipe function to automatically generate ice breakers on match creation
-- First drop the existing function
DROP FUNCTION IF EXISTS public.handle_swipe(UUID, TEXT);

-- Then create the new function
CREATE FUNCTION public.handle_swipe(
  p_swiped_id UUID,
  p_action TEXT
) RETURNS JSONB AS $$
DECLARE
  v_swiper_id UUID;
  v_swiped_id UUID;
  v_matched BOOLEAN := FALSE;
  v_match_id UUID;
  v_existing_swipe RECORD;
  v_reciprocal_swipe RECORD;
BEGIN
  -- Get current user ID
  v_swiper_id := auth.uid();
  
  -- Validate input
  IF v_swiper_id IS NULL THEN
    RETURN jsonb_build_object('error', 'User not authenticated');
  END IF;
  
  IF p_swiped_id IS NULL THEN
    RETURN jsonb_build_object('error', 'Invalid swiped user ID');
  END IF;
  
  -- CRITICAL FIX: Prevent self-matching
  IF v_swiper_id = p_swiped_id THEN
    RETURN jsonb_build_object('error', 'Cannot swipe on yourself');
  END IF;
  
  -- Validate action
  IF p_action NOT IN ('like', 'pass', 'super_like') THEN
    RETURN jsonb_build_object('error', 'Invalid action');
  END IF;
  
  -- Check if profiles exist and are active
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = v_swiper_id AND is_active = true
  ) THEN
    RETURN jsonb_build_object('error', 'Swiper profile not found or inactive');
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = p_swiped_id AND is_active = true
  ) THEN
    RETURN jsonb_build_object('error', 'Swiped profile not found or inactive');
  END IF;
  
  -- Insert or update swipe
  INSERT INTO public.swipes (swiper_id, swiped_id, action)
  VALUES (v_swiper_id, p_swiped_id, p_action)
  ON CONFLICT (swiper_id, swiped_id)
  DO UPDATE SET 
    action = EXCLUDED.action,
    created_at = NOW();
  
  -- Check for match only if action is like or super_like
  IF p_action IN ('like', 'super_like') THEN
    -- Check for reciprocal like
    SELECT * INTO v_reciprocal_swipe
    FROM public.swipes
    WHERE swiper_id = p_swiped_id 
      AND swiped_id = v_swiper_id 
      AND action IN ('like', 'super_like');
    
    IF FOUND THEN
      -- Create match with proper ordering (user_id_1 < user_id_2)
      v_swiped_id := p_swiped_id;
      
      INSERT INTO public.matches (user_id_1, user_id_2, status)
      VALUES (
        LEAST(v_swiper_id, v_swiped_id),
        GREATEST(v_swiper_id, v_swiped_id),
        'matched'
      )
      ON CONFLICT (user_id_1, user_id_2) DO NOTHING
      RETURNING id INTO v_match_id;
      
      -- Get the match ID if it was created
      IF v_match_id IS NULL THEN
        SELECT id INTO v_match_id
        FROM public.matches
        WHERE user_id_1 = LEAST(v_swiper_id, v_swiped_id)
          AND user_id_2 = GREATEST(v_swiper_id, v_swiped_id);
      END IF;
      
      v_matched := TRUE;
      
      -- NEW: Automatically generate ice breakers for new matches
      IF v_match_id IS NOT NULL THEN
        -- Insert a record to trigger ice breaker generation
        -- This will be picked up by the edge function or a background job
        INSERT INTO public.match_enhancements (
          match_id,
          astro_compatibility,
          ice_breakers,
          expires_at,
          created_at
        ) VALUES (
          v_match_id,
          NULL, -- Will be generated later if user requests astro compatibility
          NULL, -- Will be generated by the edge function
          NOW() + INTERVAL '7 days', -- Expires in 7 days
          NOW()
        ) ON CONFLICT (match_id) DO NOTHING;
        
        -- Trigger the edge function to generate ice breakers
        -- Note: This is a fire-and-forget call, don't wait for response
        PERFORM net.http_post(
          url := current_setting('app.supabase_url') || '/functions/v1/generate-match-insights',
          headers := jsonb_build_object(
            'Content-Type', 'application/json',
            'Authorization', 'Bearer ' || current_setting('app.service_role_key')
          ),
          body := jsonb_build_object('matchId', v_match_id)
        );
      END IF;
    END IF;
  END IF;
  
  -- Return result
  RETURN jsonb_build_object(
    'matched', v_matched,
    'match_id', v_match_id,
    'action', p_action,
    'swiper_id', v_swiper_id,
    'swiped_id', p_swiped_id
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object('error', SQLERRM);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enable the http extension if not already enabled
CREATE EXTENSION IF NOT EXISTS http;

-- Set the required settings (you'll need to set these in your Supabase dashboard)
-- ALTER DATABASE postgres SET app.supabase_url = 'your-supabase-url';
-- ALTER DATABASE postgres SET app.service_role_key = 'your-service-role-key';
